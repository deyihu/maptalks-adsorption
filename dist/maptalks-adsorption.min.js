/*!
 * maptalks-adsorption v0.0.1
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("maptalks")):"function"==typeof define&&define.amd?define(["exports","maptalks"],e):e((t=t||self).maptalks=t.maptalks||{},t.maptalks)}(this,(function(t,e){"use strict";const o=new e.Point(0,0);function n(t,e,o){return e.coordToContainerPoint(t,null,o)}const s=[[0,0],[0,0]],i=[0,0];function r(t,e){const n=t[0],s=t[1],i=s[0]-n[0],r=s[1]-n[1],m=i*(e[0]-n[0])+r*(e[1]-n[1]);if(m<=0)return n;const a=i*i+r*r;if(m>=a)return s;const c=m/a;return o.x=n[0]+c*i,o.y=n[1]+c*r,o}const m=new e.Point(0,0),a=new e.Point(0,0),c=new e.Point(0,0),h=new e.Point(0,0),u=new e.Extent(0,0,0,0),y=new e.Coordinate(0,0);class f extends e.Class{constructor(t,e){super(e),this.map=t,this._mousePoint=null,this.map.on("mousemove",this._mouseMove,this)}_mouseMove(t){return this._mousePoint=t.containerPoint,this}_validateMousePosition(t){return this._mousePoint&&this._mousePoint.distanceTo(t)<=this.options.tolerance+5}setGeometry(t){this.removeGeometry(),this.geometry=t;return this.geometry.adsorb=t=>{if(!t)return;let o;const n=this.options.fiterGeometries;if(n&&e.Util.isFunction(n)&&(o=n()),!o||0===o.length){o=this.geometry.getLayer().getGeometries().filter((t=>t!==this.geometry))}return this._nearest(o,t)},this}removeGeometry(){return this.geometry&&delete this.geometry.adsorb,delete this.geometry,this}dispose(){this.removeGeometry(),this.map.off("mousemove",this._mouseMove,this),delete this.map,delete this._mousePoint}_nearest(t,e){let o;for(let n=0,s=t.length;n<s&&(t[n]===this.geometry||(o=this._nearestGeometry(t[n],e),!o));n++);return o||this._mousePoint&&this._mousePoint.copy()}_nearestGeometry(t,f){if(t.getGeometries){const e=t.getGeometries();for(let t=0,o=e.length;t<o;t++){const o=this._nearestGeometry(e[t],f);if(o)return o}return}const l=Math.max(this.options.tolerance,1),x=t.getCoordinates(),p=this.map,d=t=>f.distanceTo(t)<=l&&this._validateMousePosition(t);if(t instanceof e.Marker){const t=n(x,this.map,o);if(d(t))return t.copy()}const g=t=>{const e=function(t,e,o){let s=1/0,i=1/0,r=-1/0,f=-1/0;for(let e=0,o=t.length;e<o;e++){const{x:o,y:n}=t[e];s=Math.min(o,s),i=Math.min(n,i),r=Math.max(o,r),f=Math.max(n,f)}y.x=s,y.y=i;const l=n(y,e,m);y.x=s,y.y=f;const x=n(y,e,a);y.x=r,y.y=f;const p=n(y,e,c);y.x=r,y.y=i;const d=n(y,e,h);return u.xmin=Math.min(l.x,x.x,p.x,d.x)-o,u.ymin=Math.min(l.y,x.y,p.y,d.y)-o,u.xmax=Math.max(l.x,x.x,p.x,d.x)+o,u.ymax=Math.max(l.y,x.y,p.y,d.y)+o,u}(t,p,l),{x:x,y:g}=f;if(x<e.xmin||g<e.ymin||x>e.xmax||g>e.ymax)return;const _=t.length;let P,M=0;for(;M<_-1;M++){const e=t[M],c=P||n(e,p,o);if(!P&&d(c))return c.copy();const h=n(t[M+1],p,m);if(d(h))return h.copy();s[0][0]=c.x,s[0][1]=c.y,s[1][0]=h.x,s[1][1]=h.y,i[0]=f.x,i[1]=f.y;const u=r(s,i);if(d(u))return u.copy();P=a,P.x=h.x,P.y=h.y}};if(t instanceof e.LineString){const t=g(x);if(t)return t.copy()}if(t instanceof e.Polygon)for(let t=0,e=x.length;t<e;t++){const e=g(x[t]);if(e)return e.copy()}}_sortGeometries(t,e){const o=this.map;return t.forEach((t=>{const s=t.getCenter();if(!s)return;const i=n(s,o);t._distance=e.distanceTo(i)})),t.sort(((t,e)=>t._distance-e._distance))}}f.mergeOptions({tolerance:15,fiterGeometries:null}),t.Adsorption=f,Object.defineProperty(t,"__esModule",{value:!0})}));
