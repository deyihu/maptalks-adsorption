/*!
 * maptalks-adsorption v0.0.1
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("maptalks")):"function"==typeof define&&define.amd?define(["exports","maptalks"],e):e((t=t||self).maptalks=t.maptalks||{},t.maptalks)}(this,(function(t,e){"use strict";const o=new e.Point(0,0),s=new e.Point(0,0);function i(t,e,o){return e.coordToContainerPoint(t,null,o)}const n=[[0,0],[0,0]],r=[0,0];function c(t,e){const s=t[0],i=t[1],n=i[0]-s[0],r=i[1]-s[1],c=n*(e[0]-s[0])+r*(e[1]-s[1]);if(c<=0)return s;const m=n*n+r*r;if(c>=m)return i;const a=c/m;return o.x=s[0]+a*n,o.y=s[1]+a*r,o}class m extends e.Class{constructor(t,e){super(e),this.map=t,this._mousePoint=null,this.map.on("mousemove",this._mouseMove,this)}_mouseMove(t){return this._mousePoint=t.containerPoint,this}_validateMousePosition(t){return this._mousePoint&&this._mousePoint.distanceTo(t)<=this.options.tolerance+5}setGeometry(t){this.removeGeometry(),this.geometry=t;return this.geometry.adsorb=t=>{if(!t)return;let o;const s=this.options.fiterGeometries;if(s&&e.Util.isFunction(s)&&(o=s()),!o||0===o.length){o=this.geometry.getLayer().getGeometries().filter((t=>t!==this.geometry))}return this._nearest(o,t)},this}removeGeometry(){return this.geometry&&delete this.geometry.adsorb,delete this.geometry,this}dispose(){this.removeGeometry(),this.map.off("mousemove",this._mouseMove,this),delete this.map,delete this._mousePoint}_nearest(t,e){for(let o=0,s=(t=this._sortGeometries(t,e)).length;o<s;o++){if(t[o]===this.geometry)continue;const s=this._nearestGeometry(t[o],e);if(s)return s}return this._mousePoint&&this._mousePoint.copy()}_nearestGeometry(t,m){if(t.getGeometries){const e=t.getGeometries();for(let t=0,o=e.length;t<o;t++){const o=this._nearestGeometry(e[t],m);if(o)return o}}const a=Math.max(this.options.tolerance,1),u=t.getCoordinates(),h=t=>m.distanceTo(t)<=a&&this._validateMousePosition(t);if(t instanceof e.Marker){const t=i(u,this.map,o);if(h(t))return t.copy()}const f=t=>{const e=t.length;let a=0;for(;a<e-1;a++){const e=i(t[a],this.map,o);if(h(e))return e.copy();const u=i(t[a+1],this.map,s);if(h(u))return u.copy();n[0][0]=e.x,n[0][1]=e.y,n[1][0]=u.x,n[1][1]=u.y,r[0]=m.x,r[1]=m.y;const f=c(n,r);if(h(f))return f.copy()}};if(t instanceof e.LineString){const t=f(u);if(t)return t.copy()}if(t instanceof e.Polygon)for(let t=0,e=u.length;t<e;t++){const e=f(u[t]);if(e)return e.copy()}}_sortGeometries(t,e){const o=this.map;return t.forEach((t=>{const s=t.getCenter();if(!s)return;const n=i(s,o);t._distance=e.distanceTo(n)})),t.sort(((t,e)=>t._distance-e._distance))}}m.mergeOptions({tolerance:15,fiterGeometries:null}),t.Adsorption=m,Object.defineProperty(t,"__esModule",{value:!0})}));
