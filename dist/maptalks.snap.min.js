/*!
 * maptalks.snap v0.0.1
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("maptalks")):"function"==typeof define&&define.amd?define(["exports","maptalks"],e):e((t=t||self).maptalks=t.maptalks||{},t.maptalks)}(this,(function(t,e){"use strict";const n=new e.Point(0,0);function o(t,e,n){return e.coordToContainerPoint(t,null,n)}const s=[[0,0],[0,0]],i=[0,0];function r(t,e){const o=t[0],s=t[1],i=s[0]-o[0],r=s[1]-o[1],a=i*(e[0]-o[0])+r*(e[1]-o[1]);if(a<=0)return n.x=o[0],n.y=o[1],n;const c=i*i+r*r;if(a>=c)return n.x=s[0],n.y=s[1],n;const m=a/c;return n.x=o[0]+m*i,n.y=o[1]+m*r,n}const a=new e.Point(0,0),c=new e.Point(0,0),m=new e.Point(0,0),u=new e.Point(0,0),h=new e.Extent(0,0,0,0),f=new e.Coordinate(0,0);class y extends e.Class{constructor(t,e){super(e),this.map=t,this._mousePoint=null,this._geometries=[],this.map.on("mousemove",this._mouseMove,this)}_mouseMove(t){return this._mousePoint=t.containerPoint,this}_validateMousePosition(t){return this._mousePoint&&this._mousePoint.distanceTo(t)<=this.options.tolerance+5}effectGeometry(t){if(this._geometries.indexOf(t)>-1)return this;this._geometries.push(t);const n=this;return t.snapTo=function(t){if(!t)return;let o;const s=n.options.fiterGeometries;if(s&&e.Util.isFunction(s)&&(o=s()),!o||!o.length){const t=this.getLayer();t&&(o=t.getGeometries())}return n._nearest(o,t,this)},this}unEffectGeometry(t){const e=this._geometries.indexOf(t);return-1===e||(this._geometries.splice(e,1),delete t.snapTo),this}dispose(){this._geometries.forEach((t=>{this.unEffectGeometry(t)})),this.map.off("mousemove",this._mouseMove,this),delete this.map,delete this._mousePoint,delete this._geometries}_nearest(t,e,n){let o;for(let s=0,i=t.length;s<i;s++){if(t[s]!==n&&(o=this._nearestGeometry(t[s],e),o))break}return o||this._mousePoint&&this._mousePoint.copy()}_nearestGeometry(t,y){if(t.getGeometries){const e=t.getGeometries();for(let t=0,n=e.length;t<n;t++){const n=this._nearestGeometry(e[t],y);if(n)return n}return}const l=Math.max(this.options.tolerance,1),x=t.getCoordinates(),p=this.map,d=t=>y.distanceTo(t)<=l&&this._validateMousePosition(t);if(t instanceof e.Marker){const t=o(x,this.map,n);return d(t)?t.copy():void 0}const _=t=>{if(!t||t.length<2)return;const e=function(t,e,n){let s=1/0,i=1/0,r=-1/0,y=-1/0;for(let e=0,n=t.length;e<n;e++){const{x:n,y:o}=t[e];s=Math.min(n,s),i=Math.min(o,i),r=Math.max(n,r),y=Math.max(o,y)}f.x=s,f.y=i;const l=o(f,e,a);f.x=s,f.y=y;const x=o(f,e,c);f.x=r,f.y=y;const p=o(f,e,m);f.x=r,f.y=i;const d=o(f,e,u);return h.xmin=Math.min(l.x,x.x,p.x,d.x)-n,h.ymin=Math.min(l.y,x.y,p.y,d.y)-n,h.xmax=Math.max(l.x,x.x,p.x,d.x)+n,h.ymax=Math.max(l.y,x.y,p.y,d.y)+n,h}(t,p,l),x=y.x,_=y.y;if(x<e.xmin||_<e.ymin||x>e.xmax||_>e.ymax)return;const g=t.length;let P,M=0;for(;M<g-1;M++){const e=t[M],m=P||o(e,p,n);if(!P&&d(m))return m.copy();const u=o(t[M+1],p,a);if(d(u))return u.copy();s[0][0]=m.x,s[0][1]=m.y,s[1][0]=u.x,s[1][1]=u.y,i[0]=y.x,i[1]=y.y;const h=r(s,i);if(d(h))return h.copy();P=c,P.x=u.x,P.y=u.y}};if(t instanceof e.LineString){const t=_(x);return t?t.copy():void 0}if(t instanceof e.Polygon)for(let t=0,e=x.length;t<e;t++){const e=_(x[t]);if(e)return e.copy()}}_sortGeometries(t,e){const n=this.map;return t.forEach((t=>{const s=t.getCenter();if(!s)return;const i=o(s,n);t._distance=e.distanceTo(i)})),t.sort(((t,e)=>t._distance-e._distance))}}y.mergeOptions({tolerance:15,fiterGeometries:null}),t.Snap=y,Object.defineProperty(t,"__esModule",{value:!0})}));
