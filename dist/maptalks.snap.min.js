/*!
 * maptalks.snap v0.0.1
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("maptalks")):"function"==typeof define&&define.amd?define(["exports","maptalks"],e):e((t=t||self).maptalks=t.maptalks||{},t.maptalks)}(this,(function(t,e){"use strict";const o=new e.Point(0,0);function n(t,e,o){return e.coordToContainerPoint(t,null,o)}const s=[[0,0],[0,0]],i=[0,0];function r(t,e){const n=t[0],s=t[1],i=s[0]-n[0],r=s[1]-n[1],a=i*(e[0]-n[0])+r*(e[1]-n[1]);if(a<=0)return o.x=n[0],o.y=n[1],o;const m=i*i+r*r;if(a>=m)return o.x=s[0],o.y=s[1],o;const c=a/m;return o.x=n[0]+c*i,o.y=n[1]+c*r,o}const a=new e.Point(0,0),m=new e.Point(0,0),c=new e.Point(0,0),u=new e.Point(0,0),h=new e.Extent(0,0,0,0),y=new e.Coordinate(0,0);class f extends e.Class{constructor(t,e){super(e),this.map=t,this._mousePoint=null,this.map.on("mousemove",this._mouseMove,this)}_mouseMove(t){return this._mousePoint=t.containerPoint,this}_validateMousePosition(t){return this._mousePoint&&this._mousePoint.distanceTo(t)<=this.options.tolerance+5}setGeometry(t){this.removeGeometry(),this.geometry=t;return this.geometry.snapTo=t=>{if(!t)return;let o;const n=this.options.fiterGeometries;if(n&&e.Util.isFunction(n)&&(o=n()),!o||0===o.length){o=this.geometry.getLayer().getGeometries()}return this._nearest(o,t)},this}removeGeometry(){return this.geometry&&delete this.geometry.snapTo,delete this.geometry,this}dispose(){this.removeGeometry(),this.map.off("mousemove",this._mouseMove,this),delete this.map,delete this._mousePoint}_nearest(t,e){let o;for(let n=0,s=t.length;n<s&&(t[n]===this.geometry||(o=this._nearestGeometry(t[n],e),!o));n++);return o||this._mousePoint&&this._mousePoint.copy()}_nearestGeometry(t,f){if(t.getGeometries){const e=t.getGeometries();for(let t=0,o=e.length;t<o;t++){const o=this._nearestGeometry(e[t],f);if(o)return o}return}const l=Math.max(this.options.tolerance,1),x=t.getCoordinates(),p=this.map,d=t=>f.distanceTo(t)<=l&&this._validateMousePosition(t);if(t instanceof e.Marker){const t=n(x,this.map,o);return d(t)?t.copy():void 0}const g=t=>{if(!t||t.length<2)return;const e=function(t,e,o){let s=1/0,i=1/0,r=-1/0,f=-1/0;for(let e=0,o=t.length;e<o;e++){const{x:o,y:n}=t[e];s=Math.min(o,s),i=Math.min(n,i),r=Math.max(o,r),f=Math.max(n,f)}y.x=s,y.y=i;const l=n(y,e,a);y.x=s,y.y=f;const x=n(y,e,m);y.x=r,y.y=f;const p=n(y,e,c);y.x=r,y.y=i;const d=n(y,e,u);return h.xmin=Math.min(l.x,x.x,p.x,d.x)-o,h.ymin=Math.min(l.y,x.y,p.y,d.y)-o,h.xmax=Math.max(l.x,x.x,p.x,d.x)+o,h.ymax=Math.max(l.y,x.y,p.y,d.y)+o,h}(t,p,l),x=f.x,g=f.y;if(x<e.xmin||g<e.ymin||x>e.xmax||g>e.ymax)return;const _=t.length;let P,M=0;for(;M<_-1;M++){const e=t[M],c=P||n(e,p,o);if(!P&&d(c))return c.copy();const u=n(t[M+1],p,a);if(d(u))return u.copy();s[0][0]=c.x,s[0][1]=c.y,s[1][0]=u.x,s[1][1]=u.y,i[0]=f.x,i[1]=f.y;const h=r(s,i);if(d(h))return h.copy();P=m,P.x=u.x,P.y=u.y}};if(t instanceof e.LineString){const t=g(x);return t?t.copy():void 0}if(t instanceof e.Polygon)for(let t=0,e=x.length;t<e;t++){const e=g(x[t]);if(e)return e.copy()}}_sortGeometries(t,e){const o=this.map;return t.forEach((t=>{const s=t.getCenter();if(!s)return;const i=n(s,o);t._distance=e.distanceTo(i)})),t.sort(((t,e)=>t._distance-e._distance))}}f.mergeOptions({tolerance:15,fiterGeometries:null}),t.Snap=f,Object.defineProperty(t,"__esModule",{value:!0})}));
